{"ast":null,"code":"import _slicedToArray from \"/Users/alishirsalimian/Desktop/Cars/ClientApp/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/alishirsalimian/Desktop/Cars/ClientApp/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/alishirsalimian/Desktop/Cars/ClientApp/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Subject, Subscription, BehaviorSubject, combineLatest, timer, EMPTY, of } from 'rxjs';\nimport { filter, debounce, switchMap, tap, delay, finalize, takeUntil, map } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, EventEmitter, Component, ChangeDetectionStrategy, Input, Output, NgModule } from '@angular/core';\nimport * as i2 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n\nfunction NgProgressComponent_ng_container_0_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 6);\n  }\n\n  if (rf & 2) {\n    var ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"box-shadow\", \"0 0 10px \" + ctx_r2.color + \", 0 0 5px \" + ctx_r2.color);\n  }\n}\n\nfunction NgProgressComponent_ng_container_0_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 7);\n    i0.ɵɵelement(1, \"div\", 8);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"border-top-color\", ctx_r3.color)(\"border-left-color\", ctx_r3.color);\n  }\n}\n\nfunction NgProgressComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 1)(2, \"div\", 2)(3, \"div\", 3);\n    i0.ɵɵtemplate(4, NgProgressComponent_ng_container_0_div_4_Template, 1, 2, \"div\", 4);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵtemplate(5, NgProgressComponent_ng_container_0_div_5_Template, 2, 4, \"div\", 5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    var state_r1 = ctx.$implicit;\n    var ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"transition\", \"opacity \" + ctx_r0.speed + \"ms \" + ctx_r0.ease);\n    i0.ɵɵattribute(\"active\", state_r1.active);\n    i0.ɵɵadvance(2);\n    i0.ɵɵstyleProp(\"transform\", state_r1.transform)(\"background-color\", ctx_r0.color)(\"transition\", state_r1.active ? \"all \" + ctx_r0.speed + \"ms \" + ctx_r0.ease : \"none\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.meteor);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.spinner);\n  }\n}\n\nvar NgProgressRef = /*#__PURE__*/function () {\n  function NgProgressRef(customConfig, _onDestroyCallback) {\n    var _this = this;\n\n    _classCallCheck(this, NgProgressRef);\n\n    this._onDestroyCallback = _onDestroyCallback; // Progress start source event (used to cancel finalizing delays)\n\n    this._started = new Subject(); // Progress start event: stream that emits only when it hasn't already started\n\n    this.started = this._started.pipe(filter(function () {\n      return !_this.isStarted;\n    })); // Progress ended source event\n\n    this._completed = new Subject(); // Progress start event: stream that emits only when it has already started\n\n    this.completed = this._completed.pipe(filter(function () {\n      return _this.isStarted;\n    })); // Stream that increments and updates the progress state\n\n    this._trickling = new Subject(); // Stream that combines \"_trickling\" and \"config\" streams\n\n    this._worker = Subscription.EMPTY;\n    this._state = new BehaviorSubject({\n      active: false,\n      value: 0\n    });\n    this._config = new BehaviorSubject(customConfig);\n    this.state = this._state.asObservable();\n    this.config = this._config.asObservable();\n    this._worker = combineLatest([this._trickling, this._config]).pipe(debounce(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          start = _ref2[0],\n          config = _ref2[1];\n\n      return timer(start ? config.debounceTime : 0);\n    }), switchMap(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n          start = _ref4[0],\n          config = _ref4[1];\n\n      return start ? _this.onTrickling(config) : _this.onComplete(config);\n    })).subscribe();\n  } // Get current progress state\n\n\n  _createClass(NgProgressRef, [{\n    key: \"snapshot\",\n    get: function get() {\n      return this._state.value;\n    } // Check if progress has started\n\n  }, {\n    key: \"isStarted\",\n    get: function get() {\n      return this.snapshot.active;\n    }\n    /**\r\n     * Start the progress\r\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      this._started.next();\n\n      this._trickling.next(true);\n    }\n    /**\r\n     * Complete the progress\r\n     */\n\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      this._trickling.next(false);\n    }\n    /**\r\n     * Increment the progress\r\n     */\n\n  }, {\n    key: \"inc\",\n    value: function inc(amount) {\n      var n = this.snapshot.value;\n\n      if (!this.isStarted) {\n        this.start();\n      } else {\n        if (typeof amount !== 'number') {\n          amount = this._config.value.trickleFunc(n);\n        }\n\n        this.set(n + amount);\n      }\n    }\n    /**\r\n     * Set the progress\r\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(n) {\n      this.setState({\n        value: this.clamp(n),\n        active: true\n      });\n    }\n    /**\r\n     * Set config\r\n     */\n\n  }, {\n    key: \"setConfig\",\n    value: function setConfig(config) {\n      this._config.next(Object.assign(Object.assign({}, this._config.value), config));\n    }\n    /**\r\n     * Destroy progress reference\r\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._worker.unsubscribe();\n\n      this._trickling.complete();\n\n      this._state.complete();\n\n      this._config.complete();\n\n      this._started.complete();\n\n      this._completed.complete();\n\n      this._onDestroyCallback();\n    }\n    /**\r\n     * Set progress state\r\n     */\n\n  }, {\n    key: \"setState\",\n    value: function setState(state) {\n      this._state.next(Object.assign(Object.assign({}, this.snapshot), state));\n    }\n    /**\r\n     * Clamps a value to be between min and max\r\n     */\n\n  }, {\n    key: \"clamp\",\n    value: function clamp(n) {\n      return Math.max(this._config.value.min, Math.min(this._config.value.max, n));\n    }\n    /**\r\n     * Keeps incrementing the progress\r\n     */\n\n  }, {\n    key: \"onTrickling\",\n    value: function onTrickling(config) {\n      var _this2 = this;\n\n      if (!this.isStarted) {\n        this.set(this._config.value.min);\n      }\n\n      return timer(0, config.trickleSpeed).pipe(tap(function () {\n        return _this2.inc();\n      }));\n    }\n    /**\r\n     * Completes then resets the progress\r\n     */\n\n  }, {\n    key: \"onComplete\",\n    value: function onComplete(config) {\n      var _this3 = this;\n\n      this._completed.next();\n\n      return !this.isStarted ? EMPTY : of({}).pipe( // Complete the progress\n      tap(function () {\n        return _this3.setState({\n          value: 100\n        });\n      }), // Deactivate the progress after a tiny delay\n      delay(config.speed * 1.7), tap(function () {\n        return _this3.setState({\n          active: false\n        });\n      }), // Use a tiny delay before resetting\n      delay(config.speed), // Force the progress to reset even it got cancelled\n      finalize(function () {\n        return _this3.setState({\n          value: 0\n        });\n      }), // Cancel any of the finalizing delays if the progress has started again\n      takeUntil(this._started));\n    }\n  }]);\n\n  return NgProgressRef;\n}();\n\nvar NG_PROGRESS_CONFIG = new InjectionToken('ngProgressConfig');\nvar defaultConfig = {\n  min: 8,\n  max: 100,\n  speed: 200,\n  debounceTime: 0,\n  trickleSpeed: 300,\n  fixed: true,\n  meteor: true,\n  thick: false,\n  spinner: true,\n  ease: 'linear',\n  color: '#1B95E0',\n  direction: 'ltr+',\n  spinnerPosition: 'right',\n  trickleFunc: function trickleFunc(n) {\n    if (n >= 0 && n < 20) return 10;\n    if (n >= 20 && n < 50) return 4;\n    if (n >= 50 && n < 80) return 2;\n    if (n >= 80 && n < 99) return 0.5;\n    return 0;\n  }\n};\nvar NgProgress = /*#__PURE__*/(function () {\n  var NgProgress = /*#__PURE__*/function () {\n    function NgProgress(config) {\n      _classCallCheck(this, NgProgress);\n\n      // Store progress bar instances\n      this._instances = new Map();\n      this.config = config ? Object.assign(Object.assign({}, defaultConfig), config) : defaultConfig;\n    }\n    /**\r\n     * Get or Create progress bar by ID\r\n     */\n\n\n    _createClass(NgProgress, [{\n      key: \"ref\",\n      value: function ref() {\n        var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'root';\n        var config = arguments.length > 1 ? arguments[1] : undefined;\n\n        if (this._instances.has(id)) {\n          // Get ProgressRef instance\n          var progressRef = this._instances.get(id);\n\n          if (config) {\n            progressRef.setConfig(Object.assign(Object.assign({}, this.config), config));\n          }\n\n          return progressRef;\n        } else {\n          // Create new ProgressRef instance\n          var _progressRef = new NgProgressRef(Object.assign(Object.assign({}, this.config), config), this.deleteInstance(id));\n\n          return this._instances.set(id, _progressRef).get(id);\n        }\n      }\n      /**\r\n       * Destroy all progress bar instances\r\n       */\n\n    }, {\n      key: \"destroyAll\",\n      value: function destroyAll() {\n        this._instances.forEach(function (ref) {\n          return ref.destroy();\n        });\n      }\n      /**\r\n       * A destroyer function for each progress bar instance\r\n       */\n\n    }, {\n      key: \"deleteInstance\",\n      value: function deleteInstance(id) {\n        var _this4 = this;\n\n        return function () {\n          _this4._instances.delete(id);\n        };\n      }\n    }]);\n\n    return NgProgress;\n  }();\n\n  NgProgress.ɵfac = function NgProgress_Factory(t) {\n    return new (t || NgProgress)(i0.ɵɵinject(NG_PROGRESS_CONFIG, 8));\n  };\n\n  NgProgress.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgProgress,\n    factory: NgProgress.ɵfac,\n    providedIn: 'root'\n  });\n  return NgProgress;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar NgProgressComponent = /*#__PURE__*/(function () {\n  var NgProgressComponent = /*#__PURE__*/function () {\n    function NgProgressComponent(_ngProgress) {\n      _classCallCheck(this, NgProgressComponent);\n\n      this._ngProgress = _ngProgress;\n      /** Creates a new instance if id is not already exists */\n\n      this.id = 'root';\n      /** Initializes inputs from the global config */\n\n      this.min = this._ngProgress.config.min;\n      this.max = this._ngProgress.config.max;\n      this.ease = this._ngProgress.config.ease;\n      this.color = this._ngProgress.config.color;\n      this.speed = this._ngProgress.config.speed;\n      this.thick = this._ngProgress.config.thick;\n      this.fixed = this._ngProgress.config.fixed;\n      this.meteor = this._ngProgress.config.meteor;\n      this.spinner = this._ngProgress.config.spinner;\n      this.trickleSpeed = this._ngProgress.config.trickleSpeed;\n      this.debounceTime = this._ngProgress.config.debounceTime;\n      this.trickleFunc = this._ngProgress.config.trickleFunc;\n      this.spinnerPosition = this._ngProgress.config.spinnerPosition;\n      this.direction = this._ngProgress.config.direction;\n      this.started = new EventEmitter();\n      this.completed = new EventEmitter();\n    }\n\n    _createClass(NgProgressComponent, [{\n      key: \"isStarted\",\n      get: function get() {\n        var _a;\n\n        return (_a = this.progressRef) === null || _a === void 0 ? void 0 : _a.isStarted;\n      }\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges() {\n        var _a; // Update progress bar config when inputs change\n\n\n        (_a = this.progressRef) === null || _a === void 0 ? void 0 : _a.setConfig({\n          max: this.max > 0 && this.max <= 100 ? this.max : 100,\n          min: this.min < 100 && this.min >= 0 ? this.min : 0,\n          speed: this.speed,\n          trickleSpeed: this.trickleSpeed,\n          trickleFunc: this.trickleFunc,\n          debounceTime: this.debounceTime\n        });\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this5 = this;\n\n        // Get progress bar service instance\n        this.progressRef = this._ngProgress.ref(this.id, {\n          max: this.max,\n          min: this.min,\n          speed: this.speed,\n          trickleSpeed: this.trickleSpeed,\n          debounceTime: this.debounceTime\n        }); // Subscribe to progress state\n\n        this.state$ = this.progressRef.state.pipe(map(function (state) {\n          return {\n            active: state.active,\n            transform: \"translate3d(\".concat(state.value, \"%,0,0)\")\n          };\n        })); // Subscribes to started and completed events on demand\n\n        if (this.started.observed) {\n          this._started = this.progressRef.started.subscribe(function () {\n            return _this5.started.emit();\n          });\n        }\n\n        if (this.completed.observed) {\n          this._completed = this.progressRef.completed.subscribe(function () {\n            return _this5.completed.emit();\n          });\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        var _a, _b, _c;\n\n        (_a = this._started) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n        (_b = this._completed) === null || _b === void 0 ? void 0 : _b.unsubscribe();\n        (_c = this.progressRef) === null || _c === void 0 ? void 0 : _c.destroy();\n      }\n    }, {\n      key: \"start\",\n      value: function start() {\n        this.progressRef.start();\n      }\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this.progressRef.complete();\n      }\n    }, {\n      key: \"inc\",\n      value: function inc(n) {\n        this.progressRef.inc(n);\n      }\n    }, {\n      key: \"set\",\n      value: function set(n) {\n        this.progressRef.set(n);\n      }\n    }]);\n\n    return NgProgressComponent;\n  }();\n\n  NgProgressComponent.ɵfac = function NgProgressComponent_Factory(t) {\n    return new (t || NgProgressComponent)(i0.ɵɵdirectiveInject(NgProgress));\n  };\n\n  NgProgressComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgProgressComponent,\n    selectors: [[\"ng-progress\"]],\n    hostAttrs: [\"role\", \"progressbar\"],\n    hostVars: 4,\n    hostBindings: function NgProgressComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"spinnerPosition\", ctx.spinnerPosition)(\"direction\", ctx.direction)(\"thick\", ctx.thick)(\"fixed\", ctx.fixed);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      min: \"min\",\n      max: \"max\",\n      ease: \"ease\",\n      color: \"color\",\n      speed: \"speed\",\n      thick: \"thick\",\n      fixed: \"fixed\",\n      meteor: \"meteor\",\n      spinner: \"spinner\",\n      trickleSpeed: \"trickleSpeed\",\n      debounceTime: \"debounceTime\",\n      trickleFunc: \"trickleFunc\",\n      spinnerPosition: \"spinnerPosition\",\n      direction: \"direction\"\n    },\n    outputs: {\n      started: \"started\",\n      completed: \"completed\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 2,\n    vars: 3,\n    consts: [[4, \"ngIf\"], [1, \"ng-progress-bar\"], [1, \"ng-bar-placeholder\"], [1, \"ng-bar\"], [\"class\", \"ng-meteor\", 3, \"boxShadow\", 4, \"ngIf\"], [\"class\", \"ng-spinner\", 4, \"ngIf\"], [1, \"ng-meteor\"], [1, \"ng-spinner\"], [1, \"ng-spinner-icon\"]],\n    template: function NgProgressComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, NgProgressComponent_ng_container_0_Template, 6, 11, \"ng-container\", 0);\n        i0.ɵɵpipe(1, \"async\");\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", i0.ɵɵpipeBind1(1, 1, ctx.state$));\n      }\n    },\n    dependencies: [i2.NgIf, i2.AsyncPipe],\n    styles: [\"[_nghost-%COMP%]{z-index:999999;pointer-events:none}[fixed=true][_nghost-%COMP%]   .ng-progress-bar[_ngcontent-%COMP%], [fixed=true][_nghost-%COMP%]   .ng-spinner[_ngcontent-%COMP%]{position:fixed}[fixed=true][_nghost-%COMP%]   .ng-spinner[_ngcontent-%COMP%]{top:15px}[fixed=true][spinnerPosition=left][_nghost-%COMP%]   .ng-spinner[_ngcontent-%COMP%]{left:15px}[fixed=true][spinnerPosition=right][_nghost-%COMP%]   .ng-spinner[_ngcontent-%COMP%]{right:15px}[thick=true][_nghost-%COMP%]   .ng-spinner-icon[_ngcontent-%COMP%]{width:24px;height:24px;border-width:3px}[thick=true][_nghost-%COMP%]   .ng-bar-placeholder[_ngcontent-%COMP%]{height:3px!important}[direction=\\\"ltr+\\\"][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [direction=ltr-][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{transform:rotate(3deg)}[direction=\\\"ltr+\\\"][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [direction=ltr-][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{transform:rotate(4deg)}[direction=\\\"ltr+\\\"][_nghost-%COMP%]   .ng-bar[_ngcontent-%COMP%], [direction=\\\"rtl+\\\"][_nghost-%COMP%]   .ng-bar[_ngcontent-%COMP%]{margin-left:-100%}[direction=\\\"ltr+\\\"][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [direction=\\\"rtl+\\\"][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{right:0}[direction=\\\"ltr+\\\"][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [direction=rtl-][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{top:-3px}[direction=\\\"ltr+\\\"][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [direction=rtl-][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{top:-4px}[direction=ltr-][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [direction=\\\"rtl+\\\"][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{bottom:-3px}[direction=ltr-][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [direction=\\\"rtl+\\\"][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{bottom:-4px}[direction=ltr-][_nghost-%COMP%]   .ng-bar-placeholder[_ngcontent-%COMP%], [direction=\\\"rtl+\\\"][_nghost-%COMP%]   .ng-bar-placeholder[_ngcontent-%COMP%]{transform:rotate(180deg)}[direction=ltr-][_nghost-%COMP%]   .ng-spinner-icon[_ngcontent-%COMP%], [direction=\\\"rtl+\\\"][_nghost-%COMP%]   .ng-spinner-icon[_ngcontent-%COMP%]{animation-directionection:reverse}[direction=\\\"rtl+\\\"][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [direction=rtl-][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{transform:rotate(-3deg)}[direction=\\\"rtl+\\\"][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [direction=rtl-][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{transform:rotate(-4deg)}[spinnerPosition=left][_nghost-%COMP%]   .ng-spinner[_ngcontent-%COMP%]{left:10px}[spinnerPosition=right][_nghost-%COMP%]   .ng-spinner[_ngcontent-%COMP%]{right:10px}.ng-progress-bar[_ngcontent-%COMP%]{position:relative;z-index:999999;top:0;left:0;width:100%;transform:scale(1);filter:alpha(opacity=0);opacity:0}.ng-progress-bar[active=true][_ngcontent-%COMP%]{filter:alpha(opacity=100);opacity:1;transition:none}.ng-bar-placeholder[_ngcontent-%COMP%]{position:absolute;height:2px;width:100%}.ng-bar[_ngcontent-%COMP%]{width:100%;height:100%;transform:translate(-100%,0,0)}.ng-meteor[_ngcontent-%COMP%]{display:block;position:absolute;width:100px;height:100%;opacity:1}.ng-spinner[_ngcontent-%COMP%]{position:absolute;display:block;z-index:1031;top:10px}.ng-spinner-icon[_ngcontent-%COMP%]{width:18px;height:18px;box-sizing:border-box;-webkit-animation:spinner-animation .25s linear infinite;animation:spinner-animation .25s linear infinite;border:2px solid transparent;border-radius:50%}@-webkit-keyframes spinner-animation{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes spinner-animation{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\"],\n    changeDetection: 0\n  });\n  return NgProgressComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar NgProgressModule = /*#__PURE__*/(function () {\n  var NgProgressModule = /*#__PURE__*/function () {\n    function NgProgressModule() {\n      _classCallCheck(this, NgProgressModule);\n    }\n\n    _createClass(NgProgressModule, null, [{\n      key: \"withConfig\",\n      value: function withConfig(config) {\n        return {\n          ngModule: NgProgressModule,\n          providers: [{\n            provide: NG_PROGRESS_CONFIG,\n            useValue: config\n          }]\n        };\n      }\n    }]);\n\n    return NgProgressModule;\n  }();\n\n  NgProgressModule.ɵfac = function NgProgressModule_Factory(t) {\n    return new (t || NgProgressModule)();\n  };\n\n  NgProgressModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgProgressModule\n  });\n  NgProgressModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return NgProgressModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\r\n * Public API Surface of ngx-progressbar\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { NG_PROGRESS_CONFIG, NgProgress, NgProgressComponent, NgProgressModule, NgProgressRef }; //# sourceMappingURL=ngx-progressbar.mjs.map","map":null,"metadata":{},"sourceType":"module"}